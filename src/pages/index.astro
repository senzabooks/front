---
import { client } from "../lib/sanity.js";
import { urlFor } from "../lib/sanity.js";
import Layout from "../layouts/FullBleedLayout.astro";

const data = await client.fetch(`
  *[_type == "homepage"][0]{
    featuredImages[]{
      asset->{
        _id,
        metadata { dimensions { width, height } }
      },
      alt
    }
  }
`);

const images = (data?.featuredImages ?? []).filter((img) => img?.asset);

const lowResUrls = images.map((img) =>
  urlFor(img.asset).width(64).quality(20).url()
);

/* Lower hi-res quality to reduce transferred bytes */
const hiResUrls = images.map((img) =>
  urlFor(img.asset).width(1920).quality(75).url()
);
---

<Layout title="Home">
  <div class="image-scroll" id="imageScroll">
    {images.map((img, index) => {
      const intrinsicWidth = img.asset?.metadata?.dimensions?.width ?? 1;
      const intrinsicHeight = img.asset?.metadata?.dimensions?.height ?? 1;

      return (
        <img
          class="scroll-image is-loading"
          src={lowResUrls[index]}
          data-hi={hiResUrls[index]}
          alt={img.alt ?? "Image"}
          width={intrinsicWidth}
          height={intrinsicHeight}
          loading="lazy"
          decoding="async"
        />
      );
    })}
  </div>
</Layout>

<script>
  (function () {
    const cleanupMap = new WeakMap();

    function getScrollContainer(containerElement) {
      const preferredScroller = document.getElementById("mainScroller");
      if (preferredScroller instanceof HTMLElement) return preferredScroller;

      let parentElement = containerElement.parentElement;
      while (parentElement) {
        const overflowYValue = getComputedStyle(parentElement).overflowY;
        const canScrollVertically = overflowYValue === "auto" || overflowYValue === "scroll";
        const hasScrollableContent = parentElement.scrollHeight > parentElement.clientHeight;

        if (canScrollVertically && hasScrollableContent) return parentElement;
        parentElement = parentElement.parentElement;
      }

      return null;
    }

    function init() {
      const imageContainer = document.getElementById("imageScroll");
      if (!(imageContainer instanceof HTMLElement)) return;

      if (imageContainer.dataset.inf3Inited === "1") return;
      imageContainer.dataset.inf3Inited = "1";

      const initialImages = Array.from(imageContainer.querySelectorAll("img.scroll-image"));
      if (!initialImages.length) return;

      const scrollContainer = getScrollContainer(imageContainer);

      function getScrollOffset() {
        return scrollContainer ? scrollContainer.scrollTop : window.scrollY;
      }

      function setScrollOffset(nextScrollOffset) {
        if (scrollContainer) scrollContainer.scrollTop = nextScrollOffset;
        else window.scrollTo(0, nextScrollOffset);
      }

      /* Share hi-res preloads by URL to limit repeated fetch/decode work */
      const hiResLoadCache = new Map();

      function preloadHiResOnce(hiResUrl) {
        const cachedPromise = hiResLoadCache.get(hiResUrl);
        if (cachedPromise) return cachedPromise;

        const loadPromise = new Promise((resolve, reject) => {
          const preloadImage = new Image();
          preloadImage.onload = () => resolve(undefined);
          preloadImage.onerror = () => reject(new Error("hi-res preload failed"));
          preloadImage.src = hiResUrl;
        });

        hiResLoadCache.set(hiResUrl, loadPromise);
        return loadPromise;
      }

      /* Upgrade images near viewport from low-res to hi-res */
      const hiResObserver = new IntersectionObserver(
        (entries) => {
          for (const entry of entries) {
            if (!entry.isIntersecting) continue;

            const imageElement = entry.target;
            if (!(imageElement instanceof HTMLImageElement)) continue;

            const hiResUrl = imageElement.getAttribute("data-hi");
            if (!hiResUrl || imageElement.dataset.upgraded === "1") {
              hiResObserver.unobserve(imageElement);
              continue;
            }

            imageElement.dataset.upgraded = "1";

            preloadHiResOnce(hiResUrl)
              .then(() => {
                imageElement.src = hiResUrl;
                imageElement.classList.remove("is-loading");
                hiResObserver.unobserve(imageElement);
              })
              .catch(() => {
                delete imageElement.dataset.upgraded;
              });
          }
        },
        { root: scrollContainer, rootMargin: "300px 0px", threshold: 0 }
      );

      function observeHiResImages(scopeElement) {
        scopeElement.querySelectorAll("img.scroll-image").forEach((imageElement) => {
          if (!(imageElement instanceof HTMLImageElement)) return;
          if (!imageElement.getAttribute("data-hi")) return;
          if (imageElement.dataset.upgraded === "1") return;
          hiResObserver.observe(imageElement);
        });
      }

      const middleBlockElement = document.createElement("div");
      middleBlockElement.className = "image-scroll-block";

      while (imageContainer.firstChild) {
        middleBlockElement.appendChild(imageContainer.firstChild);
      }
      imageContainer.appendChild(middleBlockElement);

      const beforeBlockClone = middleBlockElement.cloneNode(true);
      const afterBlockClone = middleBlockElement.cloneNode(true);

      if (!(beforeBlockClone instanceof HTMLElement) || !(afterBlockClone instanceof HTMLElement)) return;

      beforeBlockClone.setAttribute("aria-hidden", "true");
      afterBlockClone.setAttribute("aria-hidden", "true");

      imageContainer.insertBefore(beforeBlockClone, middleBlockElement);
      imageContainer.appendChild(afterBlockClone);

      observeHiResImages(imageContainer);

      function waitForLayout() {
        return new Promise((resolve) => {
          const startTime = performance.now();

          (function checkLayout() {
            const measuredHeight = middleBlockElement.getBoundingClientRect().height;

            if (measuredHeight > 0) {
              resolve(undefined);
              return;
            }

            if (performance.now() - startTime > 2000) {
              resolve(undefined);
              return;
            }

            requestAnimationFrame(checkLayout);
          })();
        });
      }

      let recenterTickScheduled = false;

      function recenterIfNeeded() {
        if (recenterTickScheduled) return;
        recenterTickScheduled = true;

        requestAnimationFrame(() => {
          recenterTickScheduled = false;

          const middleBlockHeight = middleBlockElement.getBoundingClientRect().height;
          if (!middleBlockHeight) return;

          const currentScrollOffset = getScrollOffset();

          const lowerBound = 0.5 * middleBlockHeight;
          const upperBound = 1.5 * middleBlockHeight;

          if (currentScrollOffset < lowerBound) {
            setScrollOffset(currentScrollOffset + middleBlockHeight);
          } else if (currentScrollOffset > upperBound) {
            setScrollOffset(currentScrollOffset - middleBlockHeight);
          }
        });
      }

      function addScrollListener() {
        const scrollTarget = scrollContainer || window;
        scrollTarget.addEventListener("scroll", recenterIfNeeded, { passive: true });
        return () => scrollTarget.removeEventListener("scroll", recenterIfNeeded);
      }

      let removeScrollListener = null;

      waitForLayout().then(() => {
        const middleBlockHeight = middleBlockElement.getBoundingClientRect().height;

        setScrollOffset(middleBlockHeight);

        requestAnimationFrame(() => setScrollOffset(middleBlockHeight));

        removeScrollListener = addScrollListener();
      });

      function destroy() {
        if (typeof removeScrollListener === "function") removeScrollListener();
        hiResObserver.disconnect();

        if (beforeBlockClone.parentNode) beforeBlockClone.parentNode.removeChild(beforeBlockClone);
        if (afterBlockClone.parentNode) afterBlockClone.parentNode.removeChild(afterBlockClone);

        const existingMiddleBlock = imageContainer.querySelector(".image-scroll-block");
        if (existingMiddleBlock instanceof HTMLElement) {
          while (existingMiddleBlock.firstChild) {
            imageContainer.insertBefore(existingMiddleBlock.firstChild, existingMiddleBlock);
          }
          existingMiddleBlock.remove();
        }

        delete imageContainer.dataset.inf3Inited;
        cleanupMap.delete(imageContainer);
      }

      cleanupMap.set(imageContainer, destroy);
    }

    function cleanup() {
      const imageContainer = document.getElementById("imageScroll");
      if (!(imageContainer instanceof HTMLElement)) return;

      const cleanupFn = cleanupMap.get(imageContainer);
      if (typeof cleanupFn === "function") cleanupFn();
    }

    const rootElement = document.documentElement;
    if (rootElement.dataset.inf3Bound !== "1") {
      rootElement.dataset.inf3Bound = "1";
      document.addEventListener("astro:page-load", init);
      document.addEventListener("astro:after-swap", init);
      document.addEventListener("astro:before-swap", cleanup);
    }

    init();
  })();
</script>

<style lang="scss" is:global>
  html,
  body {
    margin: 0;
    overflow-x: hidden;
  }

  .image-scroll {
    width: 100vw;
  }

  .scroll-image {
    display: block;
    width: 100%;
    height: auto;
    object-fit: contain;
  }

  .scroll-image.is-loading {
    filter: blur(6px);
    transform: scale(1.01);
  }
</style>